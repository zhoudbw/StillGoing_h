class Solution( object ):
    """
        给定一个数组,它的第 i 个元素是一支给定的股票在第 i 天的价格.
        设计一个算法来计算你所能获取的最大利润.你最多可以完成 两笔 交易.
        注意：你不能同时参与多笔交易(你必须在再次购买前出售掉之前的股票).
    --
        * 状态分析:
            至多交易两次,即至多买卖两次 <=> 买卖两次 or 买卖一次 or 不买卖
            所以,一天就有五个状态,
                0 还没有进行交易
                1 第一次持有股票
                2 第一次不持有股票
                3 第二次持有股票
                4 第二次不持有股票
        * 确定dp数组及其下标的含义:
            dp[i][k] 第i天时,状态k对应的最高金额
            其中dp[i][k]为`状态分析`中的五个状态
        * 推导递推公式:
            dp[i][0] 是没有交易的状态, 显然始终维持现状即可
            dp[i][1] 是第i天时,第一次持有股票能够的大ode最高金额
                * 如何得到dp[i][1]:
                    * 1 沿用i-1天时的dp[i-1][1]
                    * 2 在第i天的时候第一次买入,即dp[i-1][0] - prices[ i ]
                -- 同理:
                * dp[ i ][ 1 ] = max( dp[ i - 1 ][ 1 ], dp[ i - 1 ][ 0 ] - prices[ i ] )
                * dp[ i ][ 2 ] = max( dp[ i - 1 ][ 2 ], dp[ i - 1 ][ 1 ] + prices[ i ] )
                * dp[ i ][ 3 ] = max( dp[ i - 1 ][ 3 ], dp[ i - 1 ][ 2 ] - prices[ i ] )
                * dp[ i ][ 4 ] = max( dp[ i - 1 ][ 4 ], dp[ i - 1 ][ 3 ] + prices[ i ] )
        * 如何初始化:
            第0天 没有操作,就是0,即：dp[0][0] = 0;
            第0天 第一次买入操作,dp[0][1] = -prices[0];
            第0天 第一次卖出操作,可以理解当天买入,当天卖出,所以dp[0][2] = 0;
            第0天 第二次买入操作,第二次买入依赖于第一次卖出的状态,其实相当于第0天第一次买入了,
                第一次卖出了,然后再买入一次(第二次买入),那么现在手头上没有现金,只要买入,现金就做相应的减少。
                所以第二次买入操作,初始化为：dp[0][3] = -prices[0];
             第0天 第二次卖出操作 同理第二次卖出初始化dp[0][4] = 0;
             **** 本题特别难的地方,其实就在于怎么初始化? ****
        * 如何遍历: 从前往后
        * 推导dp数组,检测正确性
    """

    def maxProfit( self, prices ):
        """
        :type prices: List[int]
        :rtype: int
        """
        n = len( prices )

        dp = [ [ 0, 0, 0, 0, 0 ] for i in range( n ) ]
        dp[ 0 ][ 0 ] = 0
        dp[ 0 ][ 1 ] = -prices[ 0 ]
        dp[ 0 ][ 2 ] = 0
        dp[ 0 ][ 3 ] = -prices[ 0 ]
        dp[ 0 ][ 4 ] = 0

        for i in range( 1, n ):
            # -- 0 没有操作, 这个状态, 因为没有操作, 手上的现金自然就是0, 都不需要跟新 dp[ i ][ 0 ] --
            dp[ i ][ 1 ] = max( dp[ i - 1 ][ 1 ], dp[ i - 1 ][ 0 ] - prices[ i ] )
            dp[ i ][ 2 ] = max( dp[ i - 1 ][ 2 ], dp[ i - 1 ][ 1 ] + prices[ i ] )
            dp[ i ][ 3 ] = max( dp[ i - 1 ][ 3 ], dp[ i - 1 ][ 2 ] - prices[ i ] )
            dp[ i ][ 4 ] = max( dp[ i - 1 ][ 4 ], dp[ i - 1 ][ 3 ] + prices[ i ] )

        return max( dp[ n - 1 ] )

    # --
    def maxProfit( self, prices ):
        n = len( prices )

        dp = [ 0, 0, 0, 0, 0 ]
        dp[ 1 ] = -prices[ 0 ]
        dp[ 3 ] = -prices[ 0 ]

        for i in range( 1, n ):
            dp[ 1 ] = max( dp[ 1 ], dp[ 0 ] - prices[ i ] )
            dp[ 2 ] = max( dp[ 2 ], dp[ 1 ] + prices[ i ] )
            dp[ 3 ] = max( dp[ 3 ], dp[ 2 ] - prices[ i ] )
            dp[ 4 ] = max( dp[ 4 ], dp[ 3 ] + prices[ i ] )

        # -- 很浅显的:最大的时候一定是卖出的状态,而两次卖出的状态现金最大一定是最后一次卖出 --
        # -- 所以直接返回最后位置对应值即可 --
        return dp[ 4 ]
