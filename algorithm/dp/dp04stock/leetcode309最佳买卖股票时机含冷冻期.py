class Solution( object ):
    """
        给定一个整数数组prices，其中第prices[i] 表示第 i 天的股票价格 。
        设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:
        卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
        注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
        --
        * 状态分析:
            每天买卖股票有3种状态:
                股票的状态: 是否处于冷冻期
                每天的状态: 是否持有股票
                --
                0 不处于冷冻期持有股票
                1 不处于冷冻期不持有
                2 处于冷冻期不持有股票 ( 因为卖出股票后存在一天冷冻期,所以处于冷冻期时,一定是不持有股票的 )
        * dp数组及其下标的含义:
            dp[i][j] 表示第i天的时候处于j状态的最高利润
        * 确定递推公式:
            dp[i][0] = max( dp[i-1][0], dp[i-1][1] - prices[i], dp[i-1][2] - prices[i] ) --- 状态0 ( 不处于冷冻期持有股票 )
            dp[i][1] = max( dp[i-1][1], dp[i-1][0] + prices[i], dp[i-1][2] )
                * 注: 特殊地, 由于达到冷冻期只有一个操作,就是前一天卖出股票
                * 为了简便处理, 将dp[i][1] 不处于冷冻期不持有股票拆成两个状态:
                    * 1.1 不处于冷冻期今天没有本身没有股票
                        * dp[i][1.2] = max( dp[i-1][1], dp[i-1][2] )                     --- 状态1 ( 不处于冷冻期今天没有本身没有股票 )
                    * 1.2 不处于冷冻期今天卖出股票
                        * dp[i][1.1] = dp[i-1][0] + prices[i]                            --- 状态2 ( 不处于冷冻期今天卖出股票 )
                        
            dp[i][2] = dp[i-2][0] + prices[i-1]                                          --- 状态3 ( 处于冷冻期不持有股票 )
        * 初始化
            初始化和`leetcode123买卖股票的最佳时机III`一致
        * 遍历顺序
            遍历顺序和`leetcode123买卖股票的最佳时机III`一致
    """

    def maxProfit( self, prices ):
        """
        :type prices: List[int]
        :rtype: int
        """

        n = len( prices )
        dp = [ [ 0, 0, 0, 0 ] for _ in range( n ) ]

        dp[ 0 ][ 0 ] = -prices[ 0 ]
        dp[ 0 ][ 1 ] = 0
        dp[ 0 ][ 2 ] = 0
        dp[ 0 ][ 3 ] = 0
        
        for i in range( 1, n ):
            dp[ i ][ 0 ] = max( dp[ i - 1 ][ 0 ], dp[ i - 1 ][ 1 ] - prices[ i ], dp[ i - 1 ][ 3 ] - prices[ i ] )
            dp[ i ][ 1 ] = max( dp[ i - 1 ][ 1 ], dp[ i - 1 ][ 3 ] )
            dp[ i ][ 2 ] = dp[ i - 1 ][ 0 ] + prices[ i ]
            dp[ i ][ 3 ] = dp[ i - 1 ][ 2 ]

        return max( dp[ - 1 ] )
    
# 注:
#   -- 这题的难点在于状态的划分,
#   -- 在计算小状态的时候,发现小状态之间还存在依赖关系,进而更加细致的划分状态
#   -- 动态调整状态类别,方便计算 *** --


if __name__ == '__main__':
    mPrices = [ 1, 2, 3, 0, 2 ]
    print( Solution().maxProfit( mPrices ) )

