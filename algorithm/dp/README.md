# 动态规划

    动态规划,英文：Dynamic Programming,简称DP,如果某一问题有很多重叠子问题,使用动态规划是最有效的。
    所以动态规划中每一个状态一定是由上一个状态推导出来的,这一点就区分于贪心,贪心没有状态推导,而是从局部直接选最优的,

## 动态规划的解题步骤

注意: 前提是,已经确定了本题是动态规划的题目( 每个状态,由前者状态推导出 )

    - 确定dp数组（dp table）以及下标的含义 
            -- 【注】比如斐波那契数列,返回`dp[n]`该项是第n+1项(下标从0开始),故dp数据长度为n+1 --
    - 确定递推公式
            -- 【注】推导递归公式,主要想dp[i]可以从哪些途径得到,即dp[i]的出现依赖哪些项,
            --      比如`leetcode746使用最小花费爬楼梯`,可以有两个途径得到dp[i],一个是dp[i-1],一个是dp[i-2] --
            -- 【注】一些情况是递推公式决定了dp数组要如何初始化 -- 
            -- 【注】一定要明确dp数组的含义,明确递推dp数组的来源(来源很重要) --
    - dp数组如何初始化 
            -- 【注】注意边界,如果边界影响初始化,边界情况单独处理,比如斐波那契数列的`dp[0]`和`dp[1]` --
            -- 【注】很多情况下,dp数组的初始化,被隐藏在遍历中了,遍历的时候初始化了 --
    - 确定遍历顺序
            -- 【注】在推导dp[i]的时候,一定要时刻想着dp[i]的定义,否则容易跑偏 --
    - 举例推导dp数组 
            -- 【注】 写代码前举例递推一下,代码写完后检查再递推一下,确保逻辑正确 --

## 动态规划应该如何debug

把dp数组打印出来,看看究竟是不是按照自己思路推导的

写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍,心中有数,确定最后推出的是想要的结果

灵魂拷问:

        - 这道题目我举例推导状态转移公式了么？

        - 我打印dp数组的日志了么？

        - 打印出来了dp数组和我想的一样么？

## 动态规划的优化

    - 空间优化: 其实当前状态依赖前2个,或者前3个状态,或者前n个状态,都可以做空间上的优化。所以,只需要存储当前状态所依赖的状态即可。
    - 虽然只存储状态即可,但是还要考虑计算dp数组时的遍历顺序,比如 leetcode62不同路径, 虽然过程中只需要知道两个状态就可以推出下一个状态,
        但是如果单单只存储这两个状态,对应遍历来说,就略显得不适配,所以上一层的整个状态都保留,即二维数组优化为一维数组,而不是两个数。

## 实战

### dp01BasicQuestion

在这部分,通过基础题目,掌握动态规划的做题步骤,形成体系化的分析,从而应用到之后的题目中;

### dp02BagQuestion

#### bagWith01

这部分通过AC`01背包`, 并结合动态规划方法论,解决相关题目。
    注:很关键的一点, **任取**一个物品操作, 这个物品只能取一次。
    注:分析问题还是按照动态规划的方法论去分析,逐步地,找到熟悉的东西 ( 重点: leetcode494目标和 )

    1. leetcode416分割等和子集:
        目标:只要找到的集合里能够出现sum/2的子集总和,就算是可以分割成两个相同元素和子集.
        分析:可是为什么和01背包挂钩呢?
            01背包描述的是: 给定最多装下重量为w的背包,以及n个物品; 每个物品i有重量和价值,即weights[i]和values[i];
            每件物品最多使用1次,问背包中的最大价值是多少?
        
            对应到本题: 将数字抽象成物品,数字的数值即是重量又是价值; 分割子集,那么满足每个数字最多使用1次;
            那么,令背包能够装下的最大重量w=sum/2,那么最大价值就是w => 能否把容量为sum/2的背包装满;
            这样就可以用01背包的思路去解决问题了.

        注意着重思考: 背包的容量是什么? 物品的重量和价值是什么? 等价转化的问题是什么?

    2. leetcode1049最后一块石头的重量II:
        对于本题,很重要的一点在于问题的转换: 一堆石头,局部去处理很难思考,但是整体去处理却很清晰;
        本题其实是尽量让石头分成重量相同的两堆（尽可能相同）,相撞之后剩下的石头就是最小的。
        一堆的石头重量是sum,那么我们就尽可能拼成重量为 sum/2 的石头堆。 
        这样剩下的石头堆也是尽可能接近 sum/2 的重量。 
        那么此时问题就是有一堆石头,每个石头都有自己的重量,是否可以装满最大重量为 sum/2的背包。
        leetcode416分割等和子集是求背包是否正好装满,而本题是求背包最多能装多少。






