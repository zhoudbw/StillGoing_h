class Solution( object ):
    """
        -- 给定一个由正整数组成且不存在重复数字的数组(nums)，找出和为给定目标正整数(target)的组合的个数。
        示例:
            nums = [1, 2, 3]
            target = 4
            所有可能的组合为： (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1)
            请注意，顺序不同的序列被视作不同的组合。
            因此输出为 7。
    
        -- 方法1: 回溯( 枚举所有情况,符合情况的+1,返回最终计数结果 )
        -- 方法2: 动态规划: 对于组合类问题, 求方法数, 基本上定式思维,都可以优先考虑动态规划(背包模版)
        --  分析:
                1. 确定dp数组和下标含义: dp( 从[0,i]中任意取, 满足和为target的方法数 )
                2. 确定递推公式:
                    dp的来源有两个:
                        i.  放入nums[i]的方法数: dp[i][ k - nums[i]]
                        ii. 不放nums[i]的方法数: dp[i-1][ k ]
                        dp[i][k] = dp[i-1][k-nums[i]] + dp[i-1][k]
                3. 初始化 dp[i][k]上一层dp[i-1]需要初始化
                4. 遍历顺序: 按照`完全背包一维dp排列数`的方式来遍历,先遍历容量,再遍历物品
                    如果求组合数就是外层for循环遍历物品,内层for遍历背包;
                    如果求排列数就是外层for遍历背包,内层for循环遍历物品;
    """

    def combinationSum4( self, nums, target ):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        
        w = target
        n = len( nums )
        dp = [ 0 ] * ( w + 1 )
        
        # -- 初始化: 只需要初始化dp[0]即可,一维dp中推导dp[k]需要知道左边的元素和当前的元素,
        # -- 所以只是初始化dp[0]即可,dp[0]表示不放入元素能够装满容量为0的背包的方法数,
        # -- 在递推公式中会处理放入物品的情况,所以初始化的时候只考虑不放入物品装满的方法数即可;
        # -- 补充另一种解释 --[[
        #     dp数组如何初始化
        #         因为递推公式dp[i] += dp[i - nums[j]]的缘故，dp[0]要初始化为1，这样递归其他dp[i]的时候才会有数值基础。
        #         至于dp[0] = 1 有没有意义呢？
        #         其实没有意义，所以我也不去强行解释它的意义了，因为题目中也说了：给定目标值是正整数！ 所以dp[0] = 1是没有意义的，仅仅是为了推导递推公式。
        #         至于非0下标的dp[i]应该初始为多少呢？
        #         初始化为0，这样才不会影响dp[i]累加所有的dp[i - nums[j]]。
        # ]]
        dp[ 0 ] = 1
        
        for k in range( 0, w + 1 ):
            for i in range( 0, n ):
                if k >= nums[ i ]:
                    dp[ k ] = dp[ k ] + dp[ k - nums[ i ] ]
        
        return dp[ w ]
        