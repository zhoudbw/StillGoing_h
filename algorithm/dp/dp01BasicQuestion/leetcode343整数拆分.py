class Solution( object ):
    def integerBreak( self, n ):
        """
        2 <= n <= 58
        :type n: int
        :rtype: int
        """
        # -- dp[i]表示i拆分之后的乘积最大值 --
        # -- dp[i]的来源,两个数相乘,三个数相乘,...,n个数相乘,
        
        dp = [ 0 ] * ( n + 1 )
        for i in range( 2, n + 1 ):
            # -- 当前正整数是i,那么i最小可以拆成1,最大可以拆成i-1
            for k in range( 1, i ):
                # -- 此时将i拆成 k和(i-k)两个数, 由于dp[i]的来源有多个,
                # 为了涵盖这些情况,即转换为,两个数相乘,或者多个数相乘(dp[i-k]就i-k拆分成多个的最大乘积) --
                dp[ i ] = max( dp[ i ], k * ( i - k ), k * dp[ i - k ] )
        return dp[ n ]
    
    # 注: 这里对于内层循环 range( 1, i )是可以优化的:
    #    结束条件可以是 range( 1, i - 1 ), 让 k = i - 1,的话,其实在 k = 1的时候,这一步就已经拆出来了,重复计算;
    #    更进一步的:拆分一个数n 使之乘积最大,那么一定是拆分成m个近似相同的子数相乘才是最大的。
    #    那么 k 遍历,只需要遍历到 n/2 就可以,后面就没有必要遍历了,一定不是最大值。所以 range( 1, i // 2 + 1 ) --
            
        
        
       