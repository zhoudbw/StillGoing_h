class Solution( object ):
    """
        --[[
            你是一个专业的小偷,计划偷窃沿街的房屋;每间房内都藏有一定的现金,
            影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统,
            如果两间相邻的房屋在同一晚上被小偷闯入,系统会自动报警;
            
            给定一个代表每个房屋存放金额的非负整数数组 nums,
            计算你 不触动警报装置的情况下 ,一夜之内能够偷窃到的最高金额;

            输入：[1,2,3,1]
            输出：4
            解释：偷窃 1 号房屋 (金额 = 1) ,然后偷窃 3 号房屋 (金额 = 3); 偷窃到的最高金额 = 1 + 3 = 4 ;
            
            0 <= nums.length <= 100
            0 <= nums[i] <= 400
        ]]
        -- 分析:
        -- 当前的状态我是偷还是不偷呢?
            * 当前房屋偷与不偷取决于前一个房屋的抢和不抢状态
            * 当前状态和前面状态存在一种依赖关系,这就是递推公式的来源
        
        -- 确定dp数组及其下标含义: dp[i] = [0,i]个房间能够偷到的最大金额;
        -- 确定递推公式:
            * dp[i]取决于i,偷还是不偷,
                * 如果偷,那么i-1房间就不能偷, 即 dp[i] = dp[i-2] + nums[i] ( 第i-1房一定是不考虑的 )
                * 如果不偷, 那么i-1房间势必要偷, 即 dp[i] = dp[i-1] ( 并不是一定要偷i-1房,但是需要考虑第i-1房 )
                * dp[i] = max( dp[i-2] + nums[i], dp[i - 1] )
        -- 初始化: 需要初始化 dp[i-1]和dp[i-2]即,需要初始化dp[0]和dp[1]
        -- 遍历顺序: 从前往后
    """

    def rob( self, nums ):
        """
        :type nums: List[int]
        :rtype: int
        """
        n = len( nums )
        if n == 0: return 0
        if n == 1: return nums[ 0 ]
        
        dp = [ 0 ] * len( nums )
        dp[ 0 ] = nums[ 0 ]
        dp[ 1 ] = max( nums[ 0 ], nums[ 1 ] )
        
        for i in range( 2, n ):
            dp[ i ] = max( dp[ i - 1 ], nums[ i ] + dp[ i - 2 ] )
            
        return dp[ n - 1 ]
        
    # -- [注]本题可以做空间的优化,因为dp[i]只依赖dp[i-1]和dp[i-2] --

    """
        -- 上面的写法已经很容易理解了,
        -- 下面再提供一种更加容易理解的解法
    """
    def rob( self, nums ):
        n = len( nums )
        if n == 0: return 0
        
        # -- dp数组的含义: dp[i][0]表示不偷i的最大金额; dp[i][1]表示偷i的最大金额 --
        dp = [ [ 0, 0 ] for _ in range( n ) ]
        
        # -- 抢劫第0号房屋的最大金额 --
        dp[ 0 ][ 1 ] = nums[ 0 ]
        
        for i in range( 1, n ):
            # -- ** 不抢第i个房间,那么能得到的最大值是前一个房屋抢和不抢的最大值 --
            dp[ i ][ 0 ] = max( dp[ i - 1 ][ 0 ], dp[ i - 1 ][ 1 ])
            # -- 抢第i个房间,那么前一个房屋只能是不抢 --
            dp[ i ][ 1 ] = nums[ i ] + dp[ i - 1 ][ 0 ]
        
        return max( dp[ n - 1 ][ 0 ], dp[ n - 1 ][ 1 ] )
        
        
